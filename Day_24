# StudyGroup Day 24!

# 24. 성적 통계
# https://www.acmicpc.net/problem/5800

for case in range(int(input())):
    score = list(map(int, input().split()))   # 값 입력 및 변수 생성
    length = score[0]
    score = sorted(score[1:], reverse=True)   # 리스트 길이 제외 및 정렬로 재생성
    gap = [score[i] - score[i+1] for i in range(length-1)]   # 점수 간격 파악

    print(f'Class {case+1}')   # 출력
    print(f'Max {score[0]}, Min {score[length-1]}, Largest gap {max(gap)}')

# 분명 하나도 어려운 문제는 아닌데,
# 입력 양식이 거지같아서 좀 고심했다.
# 보통은 리스트 크기와 리스트 값을 따로 넣어주지 않나...?
# 왜 그걸 한 줄에 같이 넣는거야 헷갈리게



# 오늘 제시된 문제를 안 풀고 날로 먹으려 했던 건 아니다.
# 단지... 시간이 없었을 뿐이다. 어떻게든 6시 안에 문제를 풀어야 했으니까.
# 이번 챌린저 문제도 플로이드-워셜을 이용하면 참 좋을 것 같은 문제 같은데,
# (이걸 작성하기 직전에 힌트를 잠시 본 결과 사실인 것 같다.)
# 꼭 그저께 문제가 플로이드-워셜 문제여서,
# 플로이드-워셜 알고리즘이 간단해서 그런 것도 아니다.
# 플로이드-워셜 알고리즘 특성 상 중간 기점이 중요하게 다뤄지는데,
# 해당 문제에선 가장 처음 방문해야 하는 정점을 출력해야 하니
# 중간 기점을 파악하는 플로이드-워셜 알고리즘이 적합할 것이라고 생각했기 때문이다.
# (다른 최단 경로 알고리즘도 그럴 것 같긴 하지만...)
# 저번에 플로이드-워셜 알고리즘을 제대로 이해하지 못했기에 꼭 이걸 쓰고 싶은 마음도 있었다.
# 근데 해보니, 한 가지 깨닫게 되었다.
# 플로이드-워셜 알고리즘으로 저장한 중간 기점은 마지막 중간 기점만 저장된다는 것을...
# 난 처음 중간 기점을 저장하고 싶은데, 이걸 어떻게 구현해야 할지 감을 잡지 못해 결국 중도 포기했다.



# 참고 웹사이트
1. 

# 타 레벨 문제
B. https://www.acmicpc.net/problem/3048
M. https://www.acmicpc.net/problem/2225
C. https://www.acmicpc.net/problem/1719
