# StudyGroup Day 5!

#5. 두 용액
# https://www.acmicpc.net/problem/2470

N = int(input())
nums = sorted(map(int, input().split()))   # 값 입력 및 변수 생성
bef_idx = 0
aft_idx = N-1
neutral_meter = float('inf')
best_two_liquid = [float('-inf'), float('inf')]

while bef_idx < aft_idx:
    two_liquid = [nums[bef_idx], nums[aft_idx]]   # 두 용액 선별 후
    concoction = sum(two_liquid)   # 혼합물 생성

    if neutral_meter > abs(concoction):   # '중성 척도' 갱신 시
        neutral_meter = abs(concoction)
        best_two_liquid = [nums[bef_idx], nums[aft_idx]]   # 최선의 두 용액 변경

    if concoction > 0:     # 혼합물이 염기성이라면
        aft_idx -= 1       # 염기성이 약한 쪽으로 이동
    elif concoction < 0:   # 혼합물이 산성이라면
        bef_idx += 1       # 산성이 약한 쪽으로 이동
    else:                  # 혼합물이 완벽한 중성이라면
        break              # 중단

print(*best_two_liquid)   # 출력

# 이분 탐색... 인줄 알았던 투 포인터 문제.
# 딱 보면 알겠듯이, 그렇게 어렵지 않다.
# 입력받은 값을 정렬한 뒤, 양 끝을 투 포인터로 잡아주고,
# 두 용액을 더해서 나온 값에 따라 포인터를 변경하면 된다.
# 알고리즘 분류를 봤을 때 이분 탐색과 투 포인터가 나오길래,
# 어제 문제도 있고 하니 난 저 2개를 동시에 써야 하는 줄 알고 이리저리 고민했다.
# 근데 아무리 생각해도 답이 없네. 투 포인터는 간단한데, 이분 탐색을 어떻게 같이 써야 할지 도저히 감이 오지 않았다.
# 그래서 구글링으로 남들 풀이를 확인해보니 둘 중 하나로 풀면 되는 거였네. 뭐 이딴게 다 있냐 정말로
# 이분 탐색은 여전히 방법이 떠오르지 않아서 그냥 투 포인터로 합의봤다. 이렇게 간단한걸...
# (다른 글을 보니... 뭐더라... 모든 용액을 한 번씩 돌아가면서 합이 0에 가장 근접할 다른 용액이 무엇인지 찾는 방식 같던데...
#  거기서 이분 탐색을 쓴다고. 퍽이나 쓸만하겠다.)



# 문제가 나한테 왜 이러지? 아니, 내가 문제를 제대로 못 푸는건가?
# 오늘 챌린저 문제는 비교적 쉬울 줄 알았다.
# 또 다익스트라 알고리즘을 활용해야 하는 문제가 나왔기에.
# 지정된 지점 둘의 각 최단 경로를 구해서 조건에 맞는 중점 하나를 찾는 문제였는데,
# 간단하지. 그럼 다익스트라를 2번 수행하면 되니까.
# 근데 알고리즘 분류를 보니... 뭐더라? 되게 축축할 것 같은 이름이었는데. 플루드-워셔 알고리즘이던가?
# 아, 플로이드-워셜 알고리즘이네. 이름만 비슷하면 된거지 뭐.
# 하여튼, 플로이드-워셜 알고리즘 또한 최단 경로를 구하는데 쓰이는 알고리즘인데,
# 이 알고리즘은 한 번만 수행해도 모든 중점의 각 최단 경로를 구할 수 있다.
# (선택한 중점의 각 최단 경로만 구할 수 있는 다익스트라나 벨만-포드 알고리즘과는 대조적이다.)
# 심지어 벨만-포드처럼 가중치에 음수가 존재할 경우에도 사용할 수 있다.
# 이런 강력한 성능이 있다면 문제점도 반드시 존재하는 법.
# 플로이드-워셜 알고리즘의 시간 복잡도는 O(N^3)으로 생각보다 큰 편에 속한다. 일단 절대 작다고는 말 못할듯.
# 따라서 저 시간 복잡도를 감당할 수 있는 작은 규모의 데이터셋이나 큰 시간적 여유를 가진 문제에만 해당 알고리즘을 사용할 수 있다.
# (그럼 다익스트라나 벨만-포드를 쓰지 왜 이걸 쓰냐고 말할 수 있겠지만,
#  단 1번에 모든 중점의 각 최단 경로를 구할 수 있다는 장점이 크게 작용할 때가 있기 때문에 해당 알고리즘을 쓰는 것이다.
#  난 잘 이해가 가지 않지만, 모든 중점을 파악하는 경우에는 이 알고리즘을 쓰는게 덜 복잡해진다고. 시간 복잡도도 동일하단다.
#  그냥 다른 최단 경로 알고리즘 N번 돌리면 해결되는게 아닌가 싶지만... 합당한 이유가 있겠지.)
# 일단 문제 특성상 우리에게 필요한 것은 두 지점의 각 최단 경로이므로, 일단 새로운 알고리즘을 배우는 것은 뒤로 미루고
# 다익스트라를 쓰는 방식으로 문제를 해결하려 했다.
# 하지만 문제는 오답 행진이었고...
# 처음 몇 번은 내가 구현한 다익스트라 알고리즘이 잘못됐기 때문이다.
# (어쩐지, 1%도 못 나가더라.)
# 그건 찾아서 잘 해결봤지만, 여전히 오답인건 마찬가지.
# 답답해서 질문 게시판을 보니 고통받는 사람이 꽤 많은 듯 했다.
# 다들 공통적으로 이야기하는게 '문제 설명과 조건 명시가 부적절하니 면밀히 검증해야 한다' 였던 것 같은데...
# 나도 진짜 별 괴상한 조건은 다 찾아본 것 같다. 어제 챌린저 문제가 생각나네...
# 아무리 해도 정답은 나오지 않았다. 한 8번은 도전한 것 같은데... 왜 97%에서 틀렸다고 하는지 정말 이해가 가지 않는다.
# 이거만 진짜 반나절은 붙잡은 듯. 저녁에 조금 자고 밤을 꼴딱 세웠는데도... 에휴. 그래서 그냥 포기하고 미들러로 내려왔다.
# 확실히 좀 더 쉽긴 하네... 문제 설명을 보긴 했지만, 코드는 보지 않았고, 보고 5분만에 뚝딱 해치웠으니.
# ......내가 너무 문제에 집중하느라 이상한 쪽으로 사고가 매몰된 모양이다.
# 주말엔 새로운 문제 없이 쉰다고 했으니, 못 푼 챌린저 문제나 풀어야지. 어차피 정말 매일매일 공부해야 하니까.



# 참고 웹사이트
1. https://chanhuiseok.github.io/posts/algo-50/
2. https://ljm0850.tistory.com/163
3. https://www.acmicpc.net/board/view/57752
4. https://www.acmicpc.net/board/view/60330
5. https://velog.io/@richsubin/%EB%B0%B1%EC%A4%80-2470%EB%B2%88-%EB%91%90-%EC%9A%A9%EC%95%A1-JAVA

# 타 레벨 문제
B. https://www.acmicpc.net/problem/10798
M. 
C. https://www.acmicpc.net/problem/17270
