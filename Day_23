# StudyGroup Day 23!

# 23. 회문
# https://www.acmicpc.net/problem/17609

def find_palin(word):   # 회문 탐지 사용자 정의 함수
    lft = 0
    rght = len(word) - 1   # 변수 생성
    cntr = 0

    while lft <= rght:   # 인덱스가 교차될 때까지 반복

        if word[lft] != word[rght]:   # 현재 두 인덱스 단어가 다르다면
            cntr += 1   # 일단 '단어 다름 카운트' 적립

            if word[lft+1] == word[rght]:   # 왼쪽 단어를 제거했을 때 같다면 그리 함
                lft += 1
            elif word[lft] == word[rght-1]:   # 오른쪽 단어를 제거했을 떄 같다면 그리 함
                rght -= 1
            else:
                cntr += 1   # 둘 다 아니라면 '단어 다름 카운트' 다시 적립

        if cntr > 1:   # '단어 다름 카운트'가 1 초과라면 = 회문도, 유사 회문도 될 수 없다면
            break
            
        lft += 1
        rght -= 1   # 인덱스 이동

    return cntr   # 반환


for _ in range(int(input())):
    word = input()
    cntr = min(find_palin(word), find_palin(word[::-1]), 2)   # 값 입력 및 최적 해 도출
    
    print(cntr)   # 출력

# 회문을 찾는 문제. 하지만 좀 독특한데,
# 현재 단어에서 글자 하나만 빼서 회문이 생성될 때, 이를 '유사 회문'이라 정의하고,
# 주어진 단어가 회문인지 유사 회문인지 둘 다 아닌지를 판별해야 한다.
# 음... 문제 풀이를 시작한지 얼마 안 되었을 때 회문 관련 문제를 많이 풀었지.
# 파이썬이니만큼 당시엔 주어진 문자 = 주어진 문자[::-1]인지만 판별하면 되었고, 이 방법을 거의 사용했는데,
# 이번엔 좀 복잡해보인다. 과연 어떤 단어를 빼야 회문이 될까?
# 양 쪽에서 하나씩 확인하는 방법도 생각해보긴 했지만... 이 방법을 쓴다면
# 만약 글자가 다를 때 어떤 인덱스의 글자를 제거할지 선택해야 하는데, 적합한 방법이 떠오르지 않았다.
# 결국 조금 고심하다 '내가 모르는 참신한 알고리즘이 있겠지!' 하는 마인드로 알고리즘 분류를 봤고,
# ...투 포인터란다. 아니 뭐야 내가 생각한 방법이랑 똑같잖아
# 그래도 투 포인터로 해결할 수 있다는 단서가 주어졌으니, 해답은 분명 존재할 것이다. 근데 어떻게?
# ...조금 더 고심한 결과 이 방법을 써보기로 했다.
# 단어 word, 왼쪽 인덱스 lft, 오른쪽 인덱스 rght가 있다고 가정할 때,
# word[lft] != word[rght]라면, lft+1한 뒤 비교한 결과와 rght-1한 뒤 비교한 결과를 확인해보는 것이다. 
# (각각 왼쪽 단어와 오른쪽 단어를 제거했다고 생각하면 된다.)
# 둘 중 하나가 있다면, 유사 회문일 가능성이 존재하니 일단 계속 진행하고, 아니라면 즉시 중단.
# (출력 양식이 회문 = 0, 유사 회문 = 1, 둘 다 아님 = 2인게 꽤나 중요한 단서가 되었다.
#  저걸 회문을 만들기 위해 제거한 단어 수라고 생각하면 해석이 용이하니까.)
# 코드는 생각보다 훨씬 단순하게 작성되었고,
# (원래는 len(word) // 2만큼 for문을 돌리려고 했는데, 작성 중 현재 while문 방식이 더 직관적이라는 생각이 들어
#  지금 모습이 되었다. 다시 봐도 저게 더 좋다고 생각한다.)
# 예제는 맞아 야심차게 제출했지만 10%도 못 넘기고 오답.
# 질문 게시판에서 반례를 찾아보는데, 흥미로운 반례가 하나 있었다.
# 특정 단어에 따라 오른쪽 단어를 빼야 함이 맞음에도 왼쪽 단어를 빼버려 회문이 되지 못하는 일이 발생하는 것이다.
# (이 문제는 아마 내가 if문을 작성할 때 왼쪽 단어를 제거하는 방안을 먼저 사용해서 그럴 것이다.)
# 이걸 해결하려면 어느 쪽이 더 좋을지 내부에서 판단해야 하거나, 아님... 단어를 거꾸로 돌려서 해보면 되지.
# 두 결과 중 뺀 단어가 적은 쪽이 우리가 원하는 값일테니. 그래서 여러 번 써야 하니 함수로 바꿔버렸다.
# 그런데도 틀리네. 뭐가 문제일까... 생각을 해 보다가, 문득 이런 생각이 들었다.
# '단어에 따라 함수의 반환값이 3이 될 수도 있겠네...?'
# 질문 게시판에 이를 저격한 반례는 없었고, 나도 반례를 만들진 못했지만, 저 함수 구조 상 충분히 가능한 상황이었다.
# 이를 어떻게 처리할까 고민하다가, 어차피 min을 이용해 두 결과 중 작은 값을 선택하기로 했으니,
# 거기다가 2를 넣어봤다. 이러면 내가 모르는 반례로 인해 두 결과가 모두 3이 나와도 자동으로 2로 변하겠지.
# 결과는 통과. ......뭔가 찝찝하긴 한데, 이것도 좋은 방식 아니겠는가. 수학의 함수값이 그런 거지 뭐.
# 같은 단어를 2번 반복한 것 치곤 속도도 나쁘지 않았다. 4자릿수는 나올 줄 알았는데. 코드도 엄청 단순하고.
# 물론 내 제출보다 소요 시간이 적은 코드도 있긴 했지만... 아마 다른 최적화 방법을 사용했겠지.
# 적어도 나처럼 2번 돌리진 않았을 것이다. ...근데 당장은 알고 싶지 않다.



# 참고 웹사이트
1. https://www.acmicpc.net/board/view/142381

# 타 레벨 문제
B. https://www.acmicpc.net/problem/1524
M. https://www.acmicpc.net/problem/9251
C. 
