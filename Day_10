# StudyGroup Day 10!

# 10. 한 번 남았다
# https://www.acmicpc.net/problem/13317

print(50, 49)
for i in range(50, 1, -1):   # 출력
    print(i-1, i, -1)

# 벨만-포드 알고리즘과 관련된 독특한 문제.
# 처음 문제를 읽었을 땐 도대체 이게 뭐하는건가 싶었는데,
# 몇번 더 정독해보고 채점 현황을 본 순간, '주어진 코드가 실패하는 테스트 케이스를 만드는거구나!' 하고 딱 느낌이 왔다.
# (하지만 C++로 작성된 코드였고, C++을 마지막으로 만진게 학부생 떄였으니... 최소 수년 전이다. 기억이 잘 안 난다...)
# 제출된 코드들의 바이트 크기가 이상하리만치 짧았기에 가능한 생각이었다.
# 출력도 다시 보니 왜 저런 출력인지 알게 됐고.
# 하지만 여러 조건이 있었는데, 정점의 개수 N은 50 ≤ N ≤ 100이고,
# 간선의 개수 M은 0 ≤ N ≤ N*(N-1)이며, 중복 간선은 존재할 수 없다.
# (조금 더 자세히 살펴보니, 동일 정점을 이은 간선이 가중치가 다르다면 중복으로 치지 않는 것 같았다.
#  처음엔 단방향 그래프인가 싶었지만, 꼭 그렇진 않은 것 같고...
#  단방향이든 양방향이든 두 정점에 한 간선만 존재할 수 있다면 저 간선 개수 제한이 말이 되지 않기 때문.)
# 문제에서 주목할 핵심 부분은 2가지로,
# '제시된 소스 코드의 최단 경로 갱신 과정이 N-2번만 수행되었다'와 '음의 순환을 파악해야 한다'인데,
# 따라서 제시된 소스 코드는 N-1번째 탐색에서 음의 순환 여부를 파악하고 있고,
# 해당 코드가 틀렸음을 증명하기 위해선 N-1번쨰 탐색에서 최단 경로가 갱신되는 동시에 음의 순환이 존재하지 않는 테스트 케이스를 만들면 된다.
# (N-1번째 탐색에서 최단 경로가 갱신되지 않으면서 음의 순환이 존재한다는건 논리적으로 불가능하고,
#  N-1번째 탐색에서 최단 경로가 갱신되지 않으면서 음의 순환이 존재하지 않으면 해당 코드가 틀린지 검증할 수 없으며,
#  N-1번째 탐색에서 최단 경로가 갱신되면서 음의 순환이 존재하는 경우 또한 검증할 수 없다.)
# 대체 그런 그래프가 뭐가 있을까... 생각하던 중에, 일직선 그래프라면 어떨까 싶었다.
# (처음엔 정점 최소치인 50개에서 일부만 연결된 그래프를 생각해봤는데, 저러면 어떤 그래프든 저 3가지 불가능 사유에 걸려버린다.)
# 모든 간선의 가중치가 -1이면서 일직선으로 이어진 그래프라면? 충분히 가능할 거라는 생각이 들었고, 제출해봤으나, 실패.
# 또 다른 다양한 모양의 그래프를 고민해봤지만, 아무리 생각해도 떠오르지 않았다.
# (그냥 머릿속으로 벨만-포드 알고리즘을 수행해볼걸. 그럼 이 때 문제점을 파악할 수 있었을지도 모른다. 아마도...)
# 결국 하다 쉬다를 반복하다 도저히 참지 못하고 구글링을 해봤다. 누군가 푼 흔적이 있네?
# C++이었지만, 풀이 과정은 볼 수 있겠지.
# ...설명은 단순하지만 체계적이고 논리적이었다. 결론은 일직선 그래프. ......나랑 완전히 똑같은데???
# 그 때, 소스 코드를 보니 매우 불길한 느낌이 들었다. for문의 범위 설정이 뭔가 이상한데...? 왜 반대로 세지??
# 긁어다 실행해봤고, 차이점은 단 하나였다. 간선의 입력 순서가 나와 정반대였던 것.
# 설마... 이거 때문에 틀렸겠어... 하는 생각을 품고 나도 입력 순서를 반대로 해 제출했더니, 정답 처리 되었다.
# ......순서 문제였다고...? 보면서 너무 허탈했다. 이거 때문에 몇 시간을 허비했다고???
# (지금에서야 생각해보니, 내가 벨만-포드 알고리즘의 작동 과정을 철저히 익히지 않고 넘어가서 그런게 아닐까 하는 생각이 든다.
#  알고리즘의 작동 과정을 설명할 때 그냥 '모든 간선을 N-1번 탐색한다'로 뭉뚱그려 말했지만,
#  탐색 순서에 따라 경로 최적화가 끝나는 시점이 달라질 수 있기 때문이다.
#  그리고 애초에 컴퓨터는 순서가 중요하기도 하고... 파이썬이야 두 변수의 값을 서로 바꾸기 위해 코드 1줄이면 가능하지만,
#  C, JAVA같은 다른 언어들은 temp같은 별도의 변수를 따로 만들어 중간에 저장해주어야 하지 않는가. 최소 3줄 필요하다.)
# 한 1분간 멍 때리고 있다가 문득 생각이 들어 기존에 제출했던 오답 코드를 시작점과 도착점을 반대로 해서 출력해봤더니, 그것도 정답 처리되었다.
# 무척이나 화가 난다... 그래, 뭐, 이제 절대 안 잊겠지. 명심하자. 순서. 입력 순서에 따라 달라질 수 있다는거.
# 꼭 이 알고리즘에만 한정된게 아니라, 다른 상황에서도 고려해야 할 중요한 사항이다.



# 어디서 이런 문제만 가지고 오는지 오늘은 홧병날 뻔했다.
# (물론 이런 어려운 개념에 답답한 상황이 많이 나오는 문제들이 내 실력 향상에 도움이 되는 문제긴 하지.
#  매니저분들께 화내는게 아닙니다. 그저 감탄스러울 뿐입니다...)
# TIL-공유방 보는 것도 고통이고... 다른 사람들은 타인의 풀이를 참고하지 않고 논리적으로 척척 푸는 것 같이 느껴지는데,
# 나는 저 단순한 사실 하나 몰라서 몇 시간을 고민하다가 남들 풀이 보고 겨우 파악하고...
# 내가 매일매일 TIL을 작성하지만 공유하지 않는 이유도 이것 때문이다. 이걸 봐봤자 다른 사람에게 도움이 될 것 같지도 않고...
# 다른 사람들을 보면 괜히 내 자신감만 하락하는 느낌이다. 다들 나보다 너무 잘 해...
# 하지만 다른 대부분의 사람들도 저렇게 느끼겠지. 슬픈 사회다. 쩝.
# ...이제 긴 설 연휴인데, 딱히 기분이 좋진 않네. 쉬는게 쉬는게 아닐 것 같다는 느낌이 막 든다.
# 당연히 지금까지 해오던게 있으니 일일 코드 풀이는 멈추지 않겠지만... 그냥 뭔가 그렇다. 항상 부족하다는 느낌?
# 그래, 여태까지 못 푼 챌린저 문제나 다시 도전해봐야겠다. 아니면... 큰 맘 먹고 백준 에메랄드 문제라도 풀던가. 골드 다음이 에메랄드 맞던가?



# 참고 웹사이트
1. https://measurezero.tistory.com/419
2. https://dalcheonroadhead.tistory.com/599
3. https://velog.io/@qnq0615/99%ED%81%B4%EB%9F%BD-%EC%BD%94%ED%85%8C-%EC%8A%A4%ED%84%B0%EB%94%94-10%EC%9D%BC%EC%B0%A8-TIL-%EB%B0%B1%EC%A4%80-%ED%95%9C-%EB%B2%88-%EB%82%A8%EC%95%98%EB%8B%A413317

# 타 레벨 문제
B. https://www.acmicpc.net/problem/32953
M. https://www.acmicpc.net/problem/2573
C. 
