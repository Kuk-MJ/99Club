# StudyGroup Day 2!

#2-1. 그대로 출력하기
# https://www.acmicpc.net/problem/11719

while True:
    try:
        print(rf'{input()}')   # 값 입출력
    except EOFError:
        break   # EOF 뜰 때까지 반복

# 꽤나 오랜만에 보는 '그대로 출력' 문제.
# 오랜만에 보는 이유가 있지. ...너무 간단해서 요깃거리도 안되니까.
# 파이썬 문자열엔 여러 포맷이 있는데, f-string도 있고, r-string도 있다.
# f-string은 {} 안에 들어간 값을 여러 서식을 적용한 문자열로 변환하는 것이 가능하고,
# r-string은 내부 문자열을 특수기능 없는 '날것'의 문자열로 인식한다.
# (엔터, 탭, 따옴표 시리즈같은 문자들.)
# 그 2개를 전부 쓰면 입력받은 동시에 날것으로 출력하는 것이 가능하지.
# 따로 개수가 주어지지 않으니 EOFError를 파악하도록 try-execpt문까지 넣어주면 끝!
# ...남들 거 보니까 한 2배는 더 짧던데, 굳이 보진 않겠다. 뭔가... 방법이 있겠지.
# 숏코딩한다고 좋은게 아니잖아?


#2-2. 랜선 자르기
# https://www.acmicpc.net/problem/1654

K, N = map(int, input().split())
lan_cables = [int(input()) for i in range(K)]   # 값 입력
lo = 1
hi = max(lan_cables)   # 범위 지정

while True:
    mid = (lo + hi) // 2   # 중간값 지정
    can_do_make = [i // mid for i in lan_cables]   # 중간값으로 잘라보기
    total = sum(can_do_make)   # 생성된 케이블 수
    
    if hi < lo:
        break   # 범위가 이상해지면 break
    
    if total >= N:
        lo = mid + 1   # 개수를 만족한다면 큰 값으로 가깝게
    else:
        hi = mid - 1   # 만족 못한다면 작은 값으로 가깝게

print(mid)   # 출력

# 원래는 반년 전에 이미 푼 문제라 여기 올라올 일이 없지만,
# 챌린저 단계 신청한 사람이 비기너 문제 풀고 뻗대면 좀 그러니까... 복기 겸해서 다시 써본다.
# 그 당시, 난 이분 탐색이 뭔지 몰랐고, 그냥 브루트 포싱하려 했는데, 어림도 없었지.
# 고심하다 알고리즘 분류를 봤고, 이분 탐색이라는 알고리즘이 쓰임을 알게 되었다.
# 이분 탐색 알고리즘을 쉽게 설명하려면, 업다운 게임을 생각하면 된다.
# 상대방이 1~N까지의 자연수 중, 어떤 수 K를 생각하고 있다고 할 때,
# 내가 다른 어떤 수 A를 말하면, 상대방은 A가 K보다 큰지, 아님 작은지, 아님 같은지 말해준다. 
# 그러면 내가 이걸 효율적으로 찾을 수 있는 방법은 뭐가 있을까?
# 1부터 N까지 순서대로 말하기? 아님 거꾸로? 그냥 무작위로 말하는건 또 어떨까? 아님 내가 좋아하는 수부터? 상대방이 좋아하는 수는?
# 다 논리적이거나 합리적이진 않지. 가장 좋은 방법은, 범위를 반절씩 줄여나가는거다. 확률에 의존하지 않는 합리적인 방법.
# 간단하게 1부터 100까지라고 가정하면, 난 그 중간인 50을 말한다.
# 만약 아니라면 1~50이나 50~100이 제외될 것이고, 또 그 중간값인 75나 25를 말하고...
# 이렇게 기존 범위의 반절을 줄여나간다는 의미에서 이분 탐색이라고 칭하는 거겠지?
# N개의 값이 존재할 때, 이분 탐색의 시간 복잡도는 O(logN). 브루트 포스의 시간 복잡도는 O(N)이니,
# 개수가 많아질수록 이분 탐색의 효율은 더더욱 강력해진다.
# 코드로 구현하는 방법을 간단히 표현하자면 다음과 같다.
# 가장 왼쪽 값 lft와, 가장 오른쪽 값 rght, 그리고 둘의 중간값인 mid를 지정해준다.
# (그게 숫자라면 숫자, 문자라면 문자, 인덱스라면 인덱스. 뭐든 상관 없다.)
# 우리가 목표로 하는 값이 mid보다 크다면, lft를 mid+1로 지정한다.
# 만약 mid보다 작다면, rght를 mid-1로 지정한다.
# 이걸 범위가 이상해질 때까지 반복하면 된다. lft가 rght보다 오른쪽에 있다던가 하는 상황.
# 범위를 재설정했는데 아직 이상해지지 않았다면, mid를 lft와 rhgt를 이용해 재설정하면 되고,
# 그렇게 탐색을 종료하면 마지막으로 수정된 mid의 값이 우리가 원하는 값이다.
# 이분 탐색을 사용할 때 주의점은, 값이 정렬된 상태여야만 사용할 수 있다는 것이다.
# 즉, 정렬할 수 없는 종류의 값들엔 이분 탐색을 사용할 수 없다. 이 점만 유의하면 된다.



# 원래는 챌린저 문제를 멋지게 풀어야 했지만, 오늘 문제의 벽은 나에게 너무 컸다.
# 트라이라는 자료구조를 사용해야 했는데, 이걸 구현하고 문자열을 저장하는 것까진 가능할지 몰라도,
# 그걸 찾는게 문제였다. 내가 참고했던 사이트에선 ?가 존재하는 상황을 고려하지 않았으니까.
# 게다가 안 쓴지 몇년 된 클래스를 사용해 구현하라고 하고...
# 언젠가 클래스를 쓰긴 하겠지만, ?가 존재한다는 것 자체가 나에겐 너무 버거워서 일단 미뤄버렸다.
# 저 정도면 조금 모자라긴 하지만 충분히 웹사이트에서 쓸만한 수준인 것 같은데,
# 카카오 블라인드 채용 기출문제라니. 블라인드 채용으로 합격하려면 간단한 단어 검색 기능을 즉석에서 구현해야 하는구나...
# 오늘도 난 목표 수준의 벽이 아주 높음을 느낀다. 그래도 포기할 순 없지.
# 공부했다는 증거를 남기긴 남겨야 하니까, 이전에 푼 미들러 문제 대신, 비기너 문제를 풀어서 제출했다.
# 5분 컷났던데. ...5분이 뭐야, 이미 몇시간 전에 1분컷해서 제출한건데...
# 추하게 도망가서 중학교 코딩 교육에서나 풀 법한 문제를 풀었지만, 다음엔 어림도 없다.
# 1보 후퇴를 위한 2보 전진일 뿐. ...? 얼레 반대네. 2보 전진을 위한 1보 후퇴일 뿐. 크흠.
# 여튼, 내가 이걸 오후 4시에 시작했는데 이걸 적는 시간이 새벽 3시 10분이다. 미쳤지 아주.
# 이제 자자. 내일은 또 뭔 문제가 나와서 날 미치게 하려나? 너무 기대된다.



# 참고 웹사이트
#1. 

# 타 레벨 문제
#B. 
#M. 
#C. https://school.programmers.co.kr/learn/courses/30/lessons/60060
