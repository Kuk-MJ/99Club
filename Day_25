# StudyGroup Day 25!

# 25. 무한 수열
# https://www.acmicpc.net/problem/1351

def inf_seq_maker(N, P, Q):   # 사용자 정의 무한 수열 생성 함수

    if N in inf_seq:
        return inf_seq[N]   # 해당 순번 무한 수열이 있다면 그걸 반환
    else:
        inf_seq[N] = inf_seq_maker(N // P, P, Q) + inf_seq_maker(N // Q, P, Q)   # 없다면 해당 순번 무한 수열 생성

    return inf_seq[N]   # 만들어진 해당 순번 무한 수열 반환

N, P, Q = map(int, input().split())   # 값 입력 및 변수 생성
inf_seq = {0 : 1}

inf_seq_maker(N, P, Q)   # 무한 수열 생성

print(inf_seq[N])   # 출력
# print(inf_seq)

# 그냥 보기만 해도 다이나믹 프로그래밍 냄새가 풀풀 나는 문제.
# 문제는 난 아직도 다이나믹 프로그래밍에 익숙해지지 않았다는 것이고...
# 그래서 고민을 조금, 아니 많이 해야 했다.
# 피보나치 수열을 다이나믹 프로그래밍으로 구현할 때와 비슷하게 접근하면 될 거라고 생각했는데,
# 문제는 입력값의 범위가 너무 크다는 거였다.
# 그렇다고 저장할 값을 제한하기엔 피보나치 수열의 경우와 달리 범위가 유동적이고...
# 결국 또 알고리즘 분류를 봤다. 해시를 쓰라네. 호오... 아주 그럴 듯하다.
# 그러면 유동적인 범위에 대처할 수 있지. 그럼그럼.
# 그래서 일단 구현을 해봤으나... 시간 초과를 벗어나지 못했다.
# 생각해보면 당연하지. 1~N+1까지 for문을 돌렸는데 시간 초과가 안 나는게 이상하다. 메모리 초과는 극복했을지언정...
# 하지만 알 수가 없었다. 그럼 어떻게 해야 하는가?
# 물론 재귀 함수를 이용한 피보나치 함수 구현법도 생각 안 한건 아니다. 재귀 함수를 가르치는데 대표적인 방법이고, 재귀 함수는 효율적이니까.
# 근데 내 기억으론 피보나치 함수를 재귀 함수로 구현하면 비효율의 극치를 달리기 때문에, 얘도 비슷할 거라 생각했다. 그래서 배제했지.
# 하지만 결국 못 참고 구글링해본 결과 어림도 없었고, 재귀 함수를 이용하면 아주 명료하고 확실하게 구할 수 있었다.
# (거기선 DFS라고 하던데... 이게 DFS인가? DFS도 재귀 함수로 구현하긴 하지만...)
# 여러 글을 참고한 결과가 이것. ...사실 참고라 하기도 뭐하다. 코드 자체가 너무 간결해서 변화를 줄 것도 없었으니.
# 여전히 이게 왜 되는지, 아니 정확히 말하자면 어떻게 효율적으로 작동하는지 모르겠다.
# 분명 피보나치 재귀 구현처럼 내부에서 재귀가 엄청 돌아갈 것 같은데... 이게 잘 된다고??? 이해가 되지 않는다.
# 뭐, 결과가 증명하니까 되는 거겠지만서도...



# 와... 어찌저찌 부트캠프가 끝났다.
# 정말 매일매일, 주말에도 개인적으로 문제를 풀긴 했지만... 난 아직 모자람을 느낀다.
# 솔직히 난이도를 챌린저로 신청하긴 했지만, 푼 챌린저 문제는 20%도 채 안 되는 것 같다.
# (심지어 오늘 문제도 미들러 문제다. 이것도 못 풀어서 구글링했고...)
# 보너스 문제도 하나도 못 풀었고... 씁쓸하다.
# 그래도 매일매일 한게 어디야. 도전자 현황을 보니 5단계 18%에 0단계 12%더만.
# (내가 18% 중 하나라는 것엔 별 감흥이 없다. 물 5단계같은 느낌이 팍팍 들어서...
#  그것보단 0단계가 12%나 있다는게 더 놀랍다. 신청해놓고 한달 동안 건들지도 않았다는 뜻이니... 그럴 거면 뭐하러 했대???)
# 거기다 해당 커리큘럼에 참여하면서 몇 가지 인지한 사실이 있다.
# 남의 코드를 보거나 참고하는 걸 부끄럽게 여기지 말자는 거랑,
# 내가 모르는 알고리즘이나 사고방식이 엄청나게 많으니 문제 선택에 있어 조금 더 공격적으로 접근해보자는 것.
# 아무래도 내가 특정 개념을 모르는 상태에서 문제를 해결하는건 무척이나 힘들고, 그건 무에서 유를 창조하는 것과 다를 바 없다고 생각한다.
# 그러니 모르면 열심히 찾아봐야지. 끙끙대면서 고민해봤자 안 되는건 안 되는거다. 도움을 구해보자.
# 연장선상으로, 내가 모르는 것이 많다는 걸 깨달았으니, 모르는 것을 아는 것으로 바꿔야겠지?
# 근데 대부분 그런건 내 수준보다 더 높은 어려운 문제들에 널려있는지라... 아무래도 문제의 난이도를 적극적으로 높여야겠다는 생각이 든다.
# 두 방법을 혼용하면 실력이 조금 더 빠르게 오르지 않을까? 머리는 더 박살나겠지만은...
# 많이 늦은 것 같지만, 절대 포기 안 할 것이다. 나도 프로그래밍 업계의 최전선에서 활약할 날이 오기를.
# 그 날을 기다리면서 오늘도 난 열심히 공부할 것이다.



# 참고 웹사이트
1. https://velog.io/@ckstn0778/%EB%B0%B1%EC%A4%80-1351%EB%B2%88-%EB%AC%B4%ED%95%9C-%EC%88%98%EC%97%B4-O-1-Python
2. https://jamie2779.tistory.com/42

# 타 레벨 문제
B. https://www.acmicpc.net/problem/31860
M. 
C. https://school.programmers.co.kr/learn/courses/30/lessons/72413
